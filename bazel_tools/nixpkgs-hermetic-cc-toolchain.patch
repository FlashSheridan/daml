diff --git a/.bazelrc b/.bazelrc
index d226e65..cf344ef 100644
--- a/.bazelrc
+++ b/.bazelrc
@@ -1 +1,2 @@
 build --host_platform=@io_tweag_rules_nixpkgs//nixpkgs/platforms:host
+build --incompatible_enable_cc_toolchain_resolution
diff --git a/WORKSPACE b/WORKSPACE
index f37ab6c..5a4939e 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -179,12 +179,11 @@ http_archive(
 
 load(
     "//nixpkgs:toolchains/go.bzl",
-    "nixpkgs_go_configure"
+    "nixpkgs_go_configure",
 )
 
 nixpkgs_go_configure(repository = "@nixpkgs")
 
-load("@io_bazel_rules_go//go:deps.bzl", "go_rules_dependencies", "go_register_toolchains")
+load("@io_bazel_rules_go//go:deps.bzl", "go_register_toolchains", "go_rules_dependencies")
 
 go_rules_dependencies()
-
diff --git a/nixpkgs/constraints/BUILD.bazel b/nixpkgs/constraints/BUILD.bazel
index 6662530..94678bd 100644
--- a/nixpkgs/constraints/BUILD.bazel
+++ b/nixpkgs/constraints/BUILD.bazel
@@ -3,7 +3,7 @@ package(default_visibility = ["//visibility:public"])
 constraint_setting(name = "nix")
 
 constraint_value(
-    name =  "support_nix",
+    name = "support_nix",
     constraint_setting = ":nix",
 )
 
diff --git a/nixpkgs/nixpkgs.bzl b/nixpkgs/nixpkgs.bzl
index fb87da4..99b525b 100644
--- a/nixpkgs/nixpkgs.bzl
+++ b/nixpkgs/nixpkgs.bzl
@@ -1,7 +1,14 @@
 """Rules for importing Nixpkgs packages."""
 
+load("@bazel_skylib//lib:paths.bzl", "paths")
+load("@bazel_skylib//lib:sets.bzl", "sets")
 load("@bazel_tools//tools/cpp:cc_configure.bzl", "cc_autoconf_impl")
-load("@bazel_tools//tools/cpp:lib_cc_configure.bzl", "get_cpu_value")
+load(
+    "@bazel_tools//tools/cpp:lib_cc_configure.bzl",
+    "get_cpu_value",
+    "get_starlark_list",
+    "write_builtin_include_directory_paths",
+)
 
 def _nixpkgs_git_repository_impl(repository_ctx):
     repository_ctx.file("BUILD")
@@ -206,7 +213,7 @@ def _nixpkgs_package_impl(repository_ctx):
         if create_build_file_if_needed:
             p = repository_ctx.path("BUILD")
             if not p.exists:
-               repository_ctx.template("BUILD", Label("@io_tweag_rules_nixpkgs//nixpkgs:BUILD.pkg"))
+                repository_ctx.template("BUILD", Label("@io_tweag_rules_nixpkgs//nixpkgs:BUILD.pkg"))
 
 _nixpkgs_package = repository_rule(
     implementation = _nixpkgs_package_impl,
@@ -244,113 +251,316 @@ def nixpkgs_package(*args, **kwargs):
     else:
         _nixpkgs_package(*args, **kwargs)
 
-def _readlink(repository_ctx, path):
-    return repository_ctx.path(path).realpath
+def _parse_cc_toolchain_info(content, filename):
+    """Parses the `CC_TOOLCHAIN_INFO` file generated by Nix.
+
+    Attrs:
+      content: string, The content of the `CC_TOOLCHAIN_INFO` file.
+      filename: string, The path to the `CC_TOOLCHAIN_INFO` file, used for error reporting.
+
+    Returns:
+      struct, The substitutions for `@bazel_tools//tools/cpp:BUILD.tpl`.
+    """
 
-def nixpkgs_cc_autoconf_impl(repository_ctx):
+    # Parse the content of CC_TOOLCHAIN_INFO.
+    #
+    # Each line has the form
+    #
+    #   <key> <value1> <value2> ...
+    info = {}
+    for line in content.splitlines():
+        fields = line.split(" ")
+        if len(fields) == 0:
+            fail(
+                "Malformed CC_TOOLCHAIN_INFO '{}': Empty line encountered.".format(filename),
+                "cc_toolchain_info",
+            )
+        info[fields[0]] = fields[1:]
+
+    # Validate the keys in CC_TOOLCHAIN_INFO.
+    expected_keys = sets.make([
+        "TOOL_NAMES",
+        "TOOL_PATHS",
+        "CXX_BUILTIN_INCLUDE_DIRECTORIES",
+        "COMPILER_FLAGS",
+        "CXX_FLAGS",
+        "LINK_FLAGS",
+        "LINK_LIBS",
+        "OPT_COMPILE_FLAGS",
+        "OPT_LINK_FLAGS",
+        "UNFILTERED_COMPILE_FLAGS",
+        "DBG_COMPILE_FLAGS",
+        "COVERAGE_COMPILE_FLAGS",
+        "COVERAGE_LINK_FLAGS",
+        "SUPPORTS_START_END_LIB",
+    ])
+    actual_keys = sets.make(info.keys())
+    missing_keys = sets.difference(expected_keys, actual_keys)
+    unexpected_keys = sets.difference(actual_keys, expected_keys)
+    if sets.length(missing_keys) > 0:
+        fail(
+            "Malformed CC_TOOLCHAIN_INFO '{}': Missing entries '{}'.".format(
+                filename,
+                "', '".join(sets.to_list(missing_keys)),
+            ),
+            "cc_toolchain_info",
+        )
+    if sets.length(unexpected_keys) > 0:
+        fail(
+            "Malformed CC_TOOLCHAIN_INFO '{}': Unexpected entries '{}'.".format(
+                filename,
+                "', '".join(sets.to_list(unexpected_keys)),
+            ),
+            "cc_toolchain_info",
+        )
+
+    return struct(
+        tool_paths = {
+            tool: path
+            for (tool, path) in zip(info["TOOL_NAMES"], info["TOOL_PATHS"])
+        },
+        cxx_builtin_include_directories = info["CXX_BUILTIN_INCLUDE_DIRECTORIES"],
+        compiler_flags = info["COMPILER_FLAGS"],
+        cxx_flags = info["CXX_FLAGS"],
+        link_flags = info["LINK_FLAGS"],
+        link_libs = info["LINK_LIBS"],
+        opt_compile_flags = info["OPT_COMPILE_FLAGS"],
+        opt_link_flags = info["OPT_LINK_FLAGS"],
+        unfiltered_compile_flags = info["UNFILTERED_COMPILE_FLAGS"],
+        dbg_compile_flags = info["DBG_COMPILE_FLAGS"],
+        coverage_compile_flags = info["COVERAGE_COMPILE_FLAGS"],
+        coverage_link_flags = info["COVERAGE_LINK_FLAGS"],
+        supports_start_end_lib = info["SUPPORTS_START_END_LIB"] == "True",
+    )
+
+def _nixpkgs_cc_toolchain_config_impl(repository_ctx):
     cpu_value = get_cpu_value(repository_ctx)
-    if not _is_supported_platform(repository_ctx):
-        cc_autoconf_impl(repository_ctx)
+    darwin = cpu_value == "darwin"
+
+    cc_toolchain_info_file = repository_ctx.path(repository_ctx.attr.cc_toolchain_info)
+    if not cc_toolchain_info_file.exists and not repository_ctx.attr.fail_not_supported:
         return
+    info = _parse_cc_toolchain_info(
+        repository_ctx.read(cc_toolchain_info_file),
+        cc_toolchain_info_file,
+    )
 
-    # Calling repository_ctx.path() on anything but a regular file
-    # fails. So the roundabout way to do the same thing is to find
-    # a regular file we know is in the workspace (i.e. the WORKSPACE
-    # file itself) and then use dirname to get the path of the workspace
-    # root.
-    workspace_file_path = repository_ctx.path(
-        Label("@nixpkgs_cc_toolchain//:WORKSPACE"),
+    # Generate the cc_toolchain workspace following the example from
+    # `@bazel_tools//tools/cpp:unix_cc_configure.bzl`.
+    repository_ctx.symlink(
+        repository_ctx.path(repository_ctx.attr._unix_cc_toolchain_config),
+        "cc_toolchain_config.bzl",
+    )
+    repository_ctx.symlink(
+        repository_ctx.path(repository_ctx.attr._armeabi_cc_toolchain_config),
+        "armeabi_cc_toolchain_config.bzl",
+    )
+    cc_wrapper_src = (
+        repository_ctx.attr._osx_cc_wrapper if darwin else repository_ctx.attr._linux_cc_wrapper
+    )
+    repository_ctx.template(
+        "cc_wrapper.sh",
+        repository_ctx.path(cc_wrapper_src),
+        {
+            "%{cc}": info.tool_paths["gcc"],
+            "%{env}": "",
+        },
     )
-    workspace_root = _execute_or_fail(
+    if darwin:
+        info.tool_paths["gcc"] = "cc_wrapper.sh"
+        info.tool_paths["ar"] = "/usr/bin/libtool"
+    write_builtin_include_directory_paths(
         repository_ctx,
-        ["dirname", workspace_file_path],
-    ).stdout.rstrip()
-
-    # Make a list of all available tools in the Nix derivation. Override
-    # the Bazel autoconfiguration with the tools we found.
-    bin_contents = _find_children(repository_ctx, workspace_root + "/bin")
-    overriden_tools = {
-        tool: _readlink(repository_ctx, entry)
-        for entry in bin_contents
-        for tool in [entry.rpartition("/")[-1]]  # Compute basename
-    }
-    cc_autoconf_impl(repository_ctx, overriden_tools = overriden_tools)
-
-nixpkgs_cc_autoconf = repository_rule(
-    implementation = nixpkgs_cc_autoconf_impl,
-    # Copied from
-    # https://github.com/bazelbuild/bazel/blob/master/tools/cpp/cc_configure.bzl.
-    # Keep in sync.
-    environ = [
-        "ABI_LIBC_VERSION",
-        "ABI_VERSION",
-        "BAZEL_COMPILER",
-        "BAZEL_HOST_SYSTEM",
-        "BAZEL_LINKOPTS",
-        "BAZEL_PYTHON",
-        "BAZEL_SH",
-        "BAZEL_TARGET_CPU",
-        "BAZEL_TARGET_LIBC",
-        "BAZEL_TARGET_SYSTEM",
-        "BAZEL_USE_CPP_ONLY_TOOLCHAIN",
-        "BAZEL_DO_NOT_DETECT_CPP_TOOLCHAIN",
-        "BAZEL_USE_LLVM_NATIVE_COVERAGE",
-        "BAZEL_VC",
-        "BAZEL_VS",
-        "BAZEL_LLVM",
-        "USE_CLANG_CL",
-        "CC",
-        "CC_CONFIGURE_DEBUG",
-        "CC_TOOLCHAIN_NAME",
-        "CPLUS_INCLUDE_PATH",
-        "GCOV",
-        "HOMEBREW_RUBY_PATH",
-        "SYSTEMROOT",
-        "VS90COMNTOOLS",
-        "VS100COMNTOOLS",
-        "VS110COMNTOOLS",
-        "VS120COMNTOOLS",
-        "VS140COMNTOOLS",
+        info.tool_paths["gcc"],
+        info.cxx_builtin_include_directories,
+    )
+    repository_ctx.template(
+        "BUILD.bazel",
+        repository_ctx.path(repository_ctx.attr._build),
+        {
+            "%{cc_toolchain_identifier}": "local",
+            "%{name}": cpu_value,
+            "%{supports_param_files}": "0" if darwin else "1",
+            "%{cc_compiler_deps}": get_starlark_list(
+                [":builtin_include_directory_paths"] + (
+                    [":cc_wrapper"] if darwin else []
+                ),
+            ),
+            "%{compiler}": "compiler",
+            "%{abi_version}": "local",
+            "%{abi_libc_version}": "local",
+            "%{host_system_name}": "local",
+            "%{target_libc}": "macosx" if darwin else "local",
+            "%{target_cpu}": cpu_value,
+            "%{target_system_name}": "local",
+            "%{tool_paths}": ",\n        ".join(
+                ['"%s": "%s"' % (k, v) for (k, v) in info.tool_paths.items()],
+            ),
+            "%{cxx_builtin_include_directories}": get_starlark_list(info.cxx_builtin_include_directories),
+            "%{compile_flags}": get_starlark_list(info.compiler_flags),
+            "%{cxx_flags}": get_starlark_list(info.cxx_flags),
+            "%{link_flags}": get_starlark_list(info.link_flags),
+            "%{link_libs}": get_starlark_list(info.link_libs),
+            "%{opt_compile_flags}": get_starlark_list(info.opt_compile_flags),
+            "%{opt_link_flags}": get_starlark_list(info.opt_link_flags),
+            "%{unfiltered_compile_flags}": get_starlark_list(info.unfiltered_compile_flags),
+            "%{dbg_compile_flags}": get_starlark_list(info.dbg_compile_flags),
+            "%{coverage_compile_flags}": get_starlark_list(info.coverage_compile_flags),
+            "%{coverage_link_flags}": get_starlark_list(info.coverage_link_flags),
+            "%{supports_start_end_lib}": repr(info.supports_start_end_lib),
+        },
+    )
+
+_nixpkgs_cc_toolchain_config = repository_rule(
+    _nixpkgs_cc_toolchain_config_impl,
+    attrs = {
+        "cc_toolchain_info": attr.label(),
+        "fail_not_supported": attr.bool(),
+        "_unix_cc_toolchain_config": attr.label(
+            default = Label("@bazel_tools//tools/cpp:unix_cc_toolchain_config.bzl"),
+        ),
+        "_armeabi_cc_toolchain_config": attr.label(
+            default = Label("@bazel_tools//tools/cpp:armeabi_cc_toolchain_config.bzl"),
+        ),
+        "_osx_cc_wrapper": attr.label(
+            default = Label("@bazel_tools//tools/cpp:osx_cc_wrapper.sh.tpl"),
+        ),
+        "_linux_cc_wrapper": attr.label(
+            default = Label("@bazel_tools//tools/cpp:linux_cc_wrapper.sh.tpl"),
+        ),
+        "_build": attr.label(
+            default = Label("@bazel_tools//tools/cpp:BUILD.tpl"),
+        ),
+    },
+)
+
+def _nixpkgs_cc_toolchain_impl(repository_ctx):
+    cpu = get_cpu_value(repository_ctx)
+    repository_ctx.file(
+        "BUILD.bazel",
+        executable = False,
+        content = """\
+package(default_visibility = ["//visibility:public"])
+
+toolchain(
+    name = "toolchain",
+    toolchain = "{cc_toolchain}",
+    toolchain_type = "@rules_cc//cc:toolchain_type",
+    exec_compatible_with = [
+        "@platforms//cpu:x86_64",
+        "@platforms//os:{os}",
+        "@io_tweag_rules_nixpkgs//nixpkgs/constraints:support_nix",
+    ],
+    target_compatible_with = [
+        "@platforms//cpu:x86_64",
+        "@platforms//os:{os}",
     ],
 )
+""".format(
+            cc_toolchain = repository_ctx.attr.cc_toolchain,
+            os = {"darwin": "osx"}.get(cpu, "linux"),
+        ),
+    )
+
+_nixpkgs_cc_toolchain = repository_rule(
+    _nixpkgs_cc_toolchain_impl,
+    attrs = {
+        # Using attr.string instead of attr.label, so that the repository rule
+        # does not explicitly depend on the nixpkgs_package instances. This is
+        # necessary, so that builds don't fail on platforms without nixpkgs.
+        "cc_toolchain": attr.string(),
+    },
+)
 
 def nixpkgs_cc_configure(
-        repository = None,
-        repositories = {},
+        name = "nixpkgs_cc_toolchain",
+        attribute_path = "",
         nix_file = None,
-        nix_file_deps = None,
-        nix_file_content = None,
-        nixopts = []):
+        nix_file_content = "",
+        nix_file_deps = [],
+        repositories = {},
+        repository = None,
+        nixopts = [],
+        quiet = False,
+        fail_not_supported = True):
     """Use a CC toolchain from Nixpkgs. No-op if not a nix-based platform.
 
     By default, Bazel auto-configures a CC toolchain from commands (e.g.
     `gcc`) available in the environment. To make builds more hermetic, use
-    this rule to specific explicitly which commands the toolchain should
-    use.
+    this rule to specify explicitly which commands the toolchain should use.
+
+    NOTE: This requires `--incompatible_enable_cc_toolchain_resolution` to be
+      enabled. See https://github.com/bazelbuild/bazel/issues/7260
+
+    Attrs:
+      attribute_path: optional, string, Obtain the toolchain from the Nix expression under this attribute path. Requires `nix_file` or `nix_file_content`.
+      nix_file: optional, Label, Obtain the toolchain from the Nix expression defined in this file. Specify only one of `nix_file` or `nix_file_content`.
+      nix_file_content: optional, string, Obtain the toolchain from the given Nix expression. Specify only one of `nix_file` or `nix_file_content`.
+      nix_file_deps: optional, list of Label, Additional files that the Nix expression depends on.
+      repositories: dict of Label to string, Provides `<nixpkgs>` and other repositories. Specify one of `repositories` or `repository`.
+      repository: Label, Provides `<nixpkgs>`. Specify one of `repositories` or `repository`.
+      quiet: bool, Whether to hide `nix-build` output.
+      fail_not_supported: bool, Whether to fail if `nix-build` is not available. XXX: Not implemented yet.
     """
-    if not nix_file and not nix_file_content:
-        nix_file_content = """
-          with import <nixpkgs> { config = {}; overlays = []; }; buildEnv {
-            name = "bazel-cc-toolchain";
-            paths = [ stdenv.cc binutils ];
-          }
-        """
+
+    if attribute_path and not (nix_file or nix_file_content):
+        fail("'attribute_path' requires one of 'nix_file' or 'nix_file_content'", "attribute_path")
+    if nix_file and nix_file_content:
+        fail("Cannot specify both 'nix_file' and 'nix_file_content'.")
+
+    nixopts = list(nixopts)
+    nix_file_deps = list(nix_file_deps)
+    if attribute_path:
+        # The `attribute_path` is forwarded to `cc.nix` as an argument.
+        nixopts.extend(["--argstr", "attribute_path", attribute_path])
+    if nix_file:
+        # The `nix_file` is forwarded to `cc.nix` as an argument. It needs to
+        # be converted from a `Label` to a filepath and then to a Nix
+        # expression using `import`.
+        #
+        # E.g. `//nix:cc.nix` becomes `import ./nix/cc.nix`.
+        #
+        # XXX: This is very confusing to use, e.g. `@//nix:cc.nix` works while
+        #   `@myworkspace//nix:cc.nix` doesn't.
+        nix_file_label = Label(nix_file)
+        nix_file_path = paths.join(
+            nix_file_label.workspace_root,
+            nix_file_label.package,
+            nix_file_label.name,
+        )
+        nixopts.extend(["--arg", "nix_expr", "import ./{}".format(nix_file_path)])
+        nix_file_deps.append(nix_file)
+    if nix_file_content:
+        # The `nix_file_content` is forwarded to `cc.nix` as an argument.
+        nixopts.extend(["--arg", "nix_expr", nix_file_content])
+
+    # Invoke `toolchains/cc.nix` which generates `CC_TOOLCHAIN_INFO`.
     nixpkgs_package(
-        name = "nixpkgs_cc_toolchain",
-        repository = repository,
-        repositories = repositories,
-        nix_file = nix_file,
+        name = "{}_cc".format(name),
+        nix_file = "@io_tweag_rules_nixpkgs//nixpkgs:toolchains/cc.nix",
         nix_file_deps = nix_file_deps,
-        nix_file_content = nix_file_content,
-        build_file_content = """exports_files(glob(["bin/*"]))""",
+        build_file_content = "exports_files(['CC_TOOLCHAIN_INFO'])",
+        repositories = repositories,
+        repository = repository,
         nixopts = nixopts,
+        quiet = quiet,
+        fail_not_supported = fail_not_supported,
+    )
+
+    # Generate the `cc_toolchain_config` workspace.
+    _nixpkgs_cc_toolchain_config(
+        name = "{}_config".format(name),
+        cc_toolchain_info = "@{}_cc//:CC_TOOLCHAIN_INFO".format(name),
+        fail_not_supported = fail_not_supported,
+    )
+
+    # Generate the `cc_toolchain` workspace.
+    _nixpkgs_cc_toolchain(
+        name = name,
+        cc_toolchain = "@{}_config//:cc-compiler-k8".format(name),
     )
 
-    # Following lines should match
-    # https://github.com/bazelbuild/bazel/blob/master/tools/cpp/cc_configure.bzl#L93.
-    nixpkgs_cc_autoconf(name = "local_config_cc")
-    native.bind(name = "cc_toolchain", actual = "@local_config_cc//:toolchain")
-    native.register_toolchains("@local_config_cc//:all")
+    native.register_toolchains("@{}//:toolchain".format(name))
 
 def _nixpkgs_python_toolchain_impl(repository_ctx):
     cpu = get_cpu_value(repository_ctx)
diff --git a/nixpkgs/toolchains/cc.nix b/nixpkgs/toolchains/cc.nix
new file mode 100644
index 0000000..4809408
--- /dev/null
+++ b/nixpkgs/toolchains/cc.nix
@@ -0,0 +1,242 @@
+with import <nixpkgs> { config = {}; overlays = []; };
+
+{ attribute_path ? null
+, nix_expr ? null
+}:
+
+let
+  cc =
+    if isNull nix_expr then
+      buildEnv {
+        name = "bazel-nixpkgs-cc";
+        # XXX: `gcov` is missing in `/bin`.
+        #   It exists in `stdenv.cc.cc` but that collides with `stdenv.cc`.
+        paths = [ stdenv.cc binutils ];
+        pathsToLink = [ "/bin" ];
+      }
+    else if isNull attribute_path then
+      nix_expr
+    else
+      lib.attrByPath (lib.splitString "." attribute_path) null nix_expr
+  ;
+in
+  runCommand "bazel-nixpkgs-cc-toolchain"
+    { executable = false;
+      # Pointless to do this on a remote machine.
+      preferLocalBuild = true;
+      allowSubstitutes = false;
+    }
+    ''
+      # This constructs the substitutions for
+      # `@bazel_tools//tools/cpp:BUILD.tpl` following the example of
+      # `@bazel_tools//tools/cpp:unix_cc_configure.bzl` as of Bazel v2.1.0 git
+      # revision 0f4c498a270f05b3896d57055b6489e824821eda.
+
+      # Determine toolchain tool paths.
+      #
+      # If a tool is not available then we use `bin/false` as a stand-in.
+      declare -A TOOLS=( [ar]=ar [cpp]=cpp [dwp]=dwp [gcc]=cc [gcov]=gcov [ld]=ld [nm]=nm [objcopy]=objcopy [objdump]=objdump [strip]=strip )
+      TOOL_NAMES=(''${!TOOLS[@]})
+      declare -A TOOL_PATHS=()
+      for tool_name in ''${!TOOLS[@]}; do
+        tool_path=${cc}/bin/''${TOOLS[$tool_name]}
+        if [[ -x $tool_path ]]; then
+          TOOL_PATHS[$tool_name]=$tool_path
+        else
+          TOOL_PATHS[$tool_name]=${coreutils}/bin/false
+        fi
+      done
+      cc=''${TOOL_PATHS[gcc]}
+
+      # Check whether a flag is supported by the compiler.
+      #
+      # The logic checks whether the flag causes an error message that contains
+      # the flag (or a pattern) verbatim. The assumption is that this will be a
+      # message of the kind `unknown argument: XYZ`. This logic is copied and
+      # adapted to bash from `@bazel_tools//tools/cpp:unix_cc_configure.bzl`.
+      is_compiler_option_supported() {
+        local option="$1"
+        local pattern="''${2-$1}"
+        { $cc "$option" -o /dev/null -c -x c++ - <<<"int main {}" 2>&1 || true; } | grep -qv -- "$pattern"
+      }
+      is_linker_option_supported() {
+        local option="$1"
+        local pattern="''${2-$1}"
+        { $cc "$option" -o /dev/null -x c++ - <<<"int main {}" 2>&1 || true; } | grep -qv -- "$pattern"
+      }
+      add_compiler_option_if_supported() {
+        if is_compiler_option_supported "$@"; then
+          echo "$1"
+        fi
+      }
+      add_linker_option_if_supported() {
+        if is_linker_option_supported "$@"; then
+          echo "$1"
+        fi
+      }
+
+      # Determine default include directories.
+      #
+      # This is copied and adapted to bash from
+      # `@bazel_tools//tools/cpp:unix_cc_configure.bzl`.
+      include_dirs_for() {
+        $cc -E -x "$1" - -v "''${@:2}" 2>&1 \
+          | sed '1,/^#include <...>/d;/^[^ ]/,$d' \
+          | xargs realpath -m
+      }
+      CXX_BUILTIN_INCLUDE_DIRECTORIES=($({
+        include_dirs_for c
+        include_dirs_for c++
+        if is_compiler_option_supported -fno-canonical-system-headers; then
+          include_dirs_for c -fno-canonical-system-headers
+          include_dirs_for c++ -std=c++0x -fno-canonical-system-headers
+        elif is_compiler_option_supported -no-canonical-prefixes; then
+          include_dirs_for c -no-canonical-prefixes
+          include_dirs_for c++ -std=c++0x -no-canonical-prefixes
+        fi
+      } 2>&1 | sort -u))
+
+      # Determine list of supported compiler and linker flags.
+      #
+      # This is copied and adapted to bash from
+      # `@bazel_tools//tools/cpp:unix_cc_configure.bzl`.
+      COMPILER_FLAGS=(
+        # Security hardening requires optimization.
+        # We need to undef it as some distributions now have it enabled by default.
+        -U_FORTIFY_SOURCE
+        -fstack-protector
+        # All warnings are enabled. Maybe enable -Werror as well?
+        -Wall
+        $(
+          # Enable a few more warnings that aren't part of -Wall.
+          add_compiler_option_if_supported -Wthread-safety
+          add_compiler_option_if_supported -Wself-assign
+          # Disable problematic warnings.
+          # XXX: Causes clang warning
+          add_compiler_option_if_supported -Wunused-but-set-parameter
+          # has false positives
+          # XXX: Causes clang warning
+          add_compiler_option_if_supported -Wno-free-nonheap-object
+          # Enable coloring even if there's no attached terminal. Bazel removes the
+          # escape sequences if --nocolor is specified.
+          add_compiler_option_if_supported -fcolor-diagnostics
+        )
+        # Keep stack frames for debugging, even in opt mode.
+        -fno-omit-frame-pointer
+      )
+      CXX_FLAGS=(-std=c++0x)
+      LINK_FLAGS=(
+        $(
+          # XXX: absolute path is only supported by clang.
+          if [[ -x ${cc}/bin/ld.gold ]]; then echo -fuse-ld=gold; fi
+          add_linker_option_if_supported -Wl,-no-as-needed -no-as-needed
+          add_linker_option_if_supported -Wl,-z,relro,-z,now -z
+        )
+        ${
+          if stdenv.isDarwin
+          then "-undefined dynamic_lookup -headerpad_max_install_names"
+          else "-B${cc}/bin"
+        }
+        $(
+          # Have gcc return the exit code from ld.
+          add_compiler_option_if_supported -pass-exit-codes
+        )
+        -lstdc++
+        -lm
+      )
+      LINK_LIBS=()
+      OPT_COMPILE_FLAGS=(
+        # No debug symbols.
+        # Maybe we should enable https://gcc.gnu.org/wiki/DebugFission for opt or
+        # even generally? However, that can't happen here, as it requires special
+        # handling in Bazel.
+        -g0
+
+        # Conservative choice for -O
+        # -O3 can increase binary size and even slow down the resulting binaries.
+        # Profile first and / or use FDO if you need better performance than this.
+        -O2
+
+        # Security hardening on by default.
+        # Conservative choice; -D_FORTIFY_SOURCE=2 may be unsafe in some cases.
+        -D_FORTIFY_SOURCE=1
+
+        # Disable assertions
+        -DNDEBUG
+
+        # Removal of unused code and data at link time (can this increase binary
+        # size in some cases?).
+        -ffunction-sections
+        -fdata-sections
+      )
+      OPT_LINK_FLAGS=(
+        ${
+          if stdenv.isDarwin
+          then ""
+          else "$(add_linker_option_if_supported -Wl,--gc-sections -gc-sections)"
+        }
+      )
+      UNFILTERED_COMPILE_FLAGS=(
+        $(
+          if is_compiler_option_supported -fno-canonical-system-headers; then
+            echo -fno-canonical-system-headers
+          elif is_compiler_option_supported -no-canonical-prefixes; then
+            echo -no-canonical-prefixes
+          fi
+        )
+        # Make C++ compilation deterministic. Use linkstamping instead of these
+        # compiler symbols.
+        -Wno-builtin-macro-redefined
+        -D__DATE__=\\\"redacted\\\"
+        -D__TIMESTAMP__=\\\"redacted\\\"
+        -D__TIME__=\\\"redacted\\\"
+      )
+      DBG_COMPILE_FLAGS=(-g)
+      COVERAGE_COMPILE_FLAGS=(
+        ${
+          if stdenv.isDarwin then
+            "-fprofile-instr-generate -fcoverage-mapping"
+          else
+            "--coverage"
+        }
+      )
+      COVERAGE_LINK_FLAGS=(
+        ${
+          if stdenv.isDarwin then
+            "-fprofile-instr-generate"
+          else
+            "--coverage"
+        }
+      )
+      SUPPORTS_START_END_LIB=(
+        $(
+          if [[ -x ${cc}/bin/ld.gold ]]; then echo True; else echo False; fi
+        )
+      )
+
+      # Write CC_TOOLCHAIN_INFO
+      #
+      # Each line has the following shape:
+      #   <key> <value1> <value2> ...
+      # I.e. each line contains one space-separated key-value pair, where the
+      # value is a space-separated list.
+      mkdir -p $out
+      write_info() {
+        local -n flags=$1
+        echo $1 "''${flags[@]}" >>$out/CC_TOOLCHAIN_INFO
+      }
+      write_info TOOL_NAMES
+      write_info TOOL_PATHS
+      write_info CXX_BUILTIN_INCLUDE_DIRECTORIES
+      write_info COMPILER_FLAGS
+      write_info CXX_FLAGS
+      write_info LINK_FLAGS
+      write_info LINK_LIBS
+      write_info OPT_COMPILE_FLAGS
+      write_info OPT_LINK_FLAGS
+      write_info UNFILTERED_COMPILE_FLAGS
+      write_info DBG_COMPILE_FLAGS
+      write_info COVERAGE_COMPILE_FLAGS
+      write_info COVERAGE_LINK_FLAGS
+      write_info SUPPORTS_START_END_LIB
+    ''
diff --git a/nixpkgs/toolchains/go.bzl b/nixpkgs/toolchains/go.bzl
index 79cbb99..d8c6366 100644
--- a/nixpkgs/toolchains/go.bzl
+++ b/nixpkgs/toolchains/go.bzl
@@ -2,20 +2,19 @@ load(
     "@io_bazel_rules_go//go:deps.bzl",
     "go_wrap_sdk",
 )
-
 load(
     "//nixpkgs:nixpkgs.bzl",
-    "nixpkgs_package"
+    "nixpkgs_package",
 )
 
 def nixpkgs_go_configure(
-    sdk_name = "go_sdk",
-    repository = None,
-    repositories = {},
-    nix_file = None,
-    nix_file_deps = None,
-    nix_file_content = None,
-    nixopts = []):
+        sdk_name = "go_sdk",
+        repository = None,
+        repositories = {},
+        nix_file = None,
+        nix_file_deps = None,
+        nix_file_content = None,
+        nixopts = []):
     """
     Use go toolchain from Nixpkgs. Will fail if not a nix-based platform.
 
@@ -41,7 +40,6 @@ def nixpkgs_go_configure(
             }
         """
 
-
     nixpkgs_package(
         name = "nixpkgs_go_toolchain",
         repository = repository,
diff --git a/tests/BUILD.bazel b/tests/BUILD.bazel
index 450810b..61bc4bc 100644
--- a/tests/BUILD.bazel
+++ b/tests/BUILD.bazel
@@ -86,5 +86,5 @@ sh_test(
 # Test nixpkgs_go_configure()
 go_binary(
     name = "go-test",
-    srcs = ["go-test.go"]
+    srcs = ["go-test.go"],
 )
